"use strict";(globalThis.webpackChunk_54vie_cookbooks=globalThis.webpackChunk_54vie_cookbooks||[]).push([[873],{8145(e,n,t){t.d(n,{R:()=>s,x:()=>o});var i=t(5410);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}},8413(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"api/api-client/cache","title":"Caching","description":"Caching strategies, cache invalidation, and offline support","source":"@site/docs/api/api-client/cache.md","sourceDirName":"api/api-client","slug":"/api/api-client/cache","permalink":"/api/api-client/cache","draft":false,"unlisted":false,"editUrl":"https://github.com/54vie/super-app/tree/main/cookbooks/docs/api/api-client/cache.md","tags":[],"version":"current","frontMatter":{"title":"Caching","description":"Caching strategies, cache invalidation, and offline support","package":"@54vie/api","category":"API Client"},"sidebar":"apiSidebar","previous":{"title":"WebSocket Client","permalink":"/api/api-client/websocket"},"next":{"title":"AnalyticsProvider","permalink":"/api/analytics/provider"}}');var a=t(5178),r=t(8145);const s={title:"Caching",description:"Caching strategies, cache invalidation, and offline support",package:"@54vie/api",category:"API Client"},o="Caching",c={},l=[{value:"Installation",id:"installation",level:2},{value:"TypeScript Interfaces",id:"typescript-interfaces",level:2},{value:"Cache Configuration",id:"cache-configuration",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Cache Storage Options",id:"cache-storage-options",level:3},{value:"Caching Strategies",id:"caching-strategies",level:2},{value:"Stale-While-Revalidate",id:"stale-while-revalidate",level:3},{value:"Cache-First",id:"cache-first",level:3},{value:"Network-First",id:"network-first",level:3},{value:"Time-Based Caching",id:"time-based-caching",level:3},{value:"Cache Invalidation",id:"cache-invalidation",level:2},{value:"Basic Invalidation",id:"basic-invalidation",level:3},{value:"Invalidation After Mutation",id:"invalidation-after-mutation",level:3},{value:"Tag-Based Invalidation",id:"tag-based-invalidation",level:3},{value:"Predicate-Based Invalidation",id:"predicate-based-invalidation",level:3},{value:"Manual Cache Updates",id:"manual-cache-updates",level:2},{value:"Setting Cache Data",id:"setting-cache-data",level:3},{value:"Optimistic Updates",id:"optimistic-updates",level:3},{value:"Prefetching",id:"prefetching",level:3},{value:"Offline Support",id:"offline-support",level:2},{value:"Basic Offline Setup",id:"basic-offline-setup",level:3},{value:"Offline Mutation Queue",id:"offline-mutation-queue",level:3},{value:"Network Status Hook",id:"network-status-hook",level:3},{value:"Optimistic Offline Updates",id:"optimistic-offline-updates",level:3},{value:"Cache Persistence",id:"cache-persistence",level:2},{value:"localStorage Persistence",id:"localstorage-persistence",level:3},{value:"Selective Persistence",id:"selective-persistence",level:3},{value:"Encrypted Persistence",id:"encrypted-persistence",level:3},{value:"Cache Garbage Collection",id:"cache-garbage-collection",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Related",id:"related",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"caching",children:"Caching"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"@54vie/api"})," package provides comprehensive caching capabilities built on TanStack Query, including intelligent cache management, cache invalidation strategies, and offline support for building resilient applications."]}),"\n",(0,a.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm install @54vie/api @tanstack/react-query\n# or\nyarn add @54vie/api @tanstack/react-query\n# or\npnpm add @54vie/api @tanstack/react-query\n"})}),"\n",(0,a.jsx)(n.h2,{id:"typescript-interfaces",children:"TypeScript Interfaces"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface CacheConfig {\n  defaultStaleTime?: number;\n  defaultGcTime?: number;\n  maxAge?: number;\n  storage?: CacheStorage;\n  encryption?: EncryptionConfig;\n  compression?: boolean;\n}\n\ninterface CacheStorage {\n  getItem: (key: string) => Promise<string | null>;\n  setItem: (key: string, value: string) => Promise<void>;\n  removeItem: (key: string) => Promise<void>;\n  clear: () => Promise<void>;\n  keys: () => Promise<string[]>;\n}\n\ninterface EncryptionConfig {\n  enabled: boolean;\n  key?: string | CryptoKey;\n  algorithm?: 'AES-GCM' | 'AES-CBC';\n}\n\ninterface CacheEntry<T = unknown> {\n  data: T;\n  timestamp: number;\n  maxAge?: number;\n  etag?: string;\n  lastModified?: string;\n}\n\ninterface CacheOptions {\n  staleTime?: number;\n  gcTime?: number;\n  cacheTime?: number; // Alias for gcTime\n  persist?: boolean;\n  tags?: string[];\n  priority?: 'low' | 'normal' | 'high';\n}\n\ninterface InvalidationOptions {\n  exact?: boolean;\n  refetchType?: 'active' | 'inactive' | 'all' | 'none';\n  throwOnError?: boolean;\n  cancelRefetch?: boolean;\n}\n\ninterface PersistConfig {\n  storage: CacheStorage;\n  key?: string;\n  maxAge?: number;\n  serialize?: (data: unknown) => string;\n  deserialize?: (data: string) => unknown;\n  filter?: (query: Query) => boolean;\n  buster?: string;\n}\n\ninterface OfflineConfig {\n  enabled?: boolean;\n  storage?: CacheStorage;\n  retryOnReconnect?: boolean;\n  syncOnReconnect?: boolean;\n  mutationQueue?: MutationQueueConfig;\n}\n\ninterface MutationQueueConfig {\n  maxSize?: number;\n  maxAge?: number;\n  retryCount?: number;\n  onSync?: (mutation: QueuedMutation) => void;\n  onSyncError?: (mutation: QueuedMutation, error: Error) => void;\n}\n\ninterface QueuedMutation {\n  id: string;\n  mutationKey: unknown[];\n  variables: unknown;\n  timestamp: number;\n  retryCount: number;\n}\n\ninterface Query {\n  queryKey: unknown[];\n  queryHash: string;\n  state: QueryState;\n}\n\ninterface QueryState<TData = unknown, TError = unknown> {\n  data: TData | undefined;\n  dataUpdatedAt: number;\n  error: TError | null;\n  errorUpdatedAt: number;\n  status: 'pending' | 'error' | 'success';\n  fetchStatus: 'fetching' | 'paused' | 'idle';\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cache-configuration",children:"Cache Configuration"}),"\n",(0,a.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { persistQueryClient } from '@tanstack/react-query-persist-client';\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      gcTime: 30 * 60 * 1000, // 30 minutes (formerly cacheTime)\n      refetchOnWindowFocus: false,\n      refetchOnReconnect: true,\n      retry: 3,\n    },\n  },\n});\n\n// Optional: Persist cache to localStorage\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n});\n\npersistQueryClient({\n  queryClient,\n  persister,\n  maxAge: 24 * 60 * 60 * 1000, // 24 hours\n});\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <YourApp />\n    </QueryClientProvider>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cache-storage-options",children:"Cache Storage Options"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// In-memory cache (default)\nconst memoryStorage: CacheStorage = {\n  cache: new Map<string, string>(),\n  getItem: async (key) => this.cache.get(key) ?? null,\n  setItem: async (key, value) => this.cache.set(key, value),\n  removeItem: async (key) => this.cache.delete(key),\n  clear: async () => this.cache.clear(),\n  keys: async () => Array.from(this.cache.keys()),\n};\n\n// localStorage\nconst localStorageCache: CacheStorage = {\n  getItem: async (key) => localStorage.getItem(key),\n  setItem: async (key, value) => localStorage.setItem(key, value),\n  removeItem: async (key) => localStorage.removeItem(key),\n  clear: async () => localStorage.clear(),\n  keys: async () => Object.keys(localStorage),\n};\n\n// IndexedDB (for larger data)\nimport { get, set, del, clear, keys } from 'idb-keyval';\n\nconst indexedDBStorage: CacheStorage = {\n  getItem: async (key) => get(key),\n  setItem: async (key, value) => set(key, value),\n  removeItem: async (key) => del(key),\n  clear: async () => clear(),\n  keys: async () => keys(),\n};\n"})}),"\n",(0,a.jsx)(n.h2,{id:"caching-strategies",children:"Caching Strategies"}),"\n",(0,a.jsx)(n.h3,{id:"stale-while-revalidate",children:"Stale-While-Revalidate"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useQuery } from '@54vie/api';\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, isLoading, isFetching } = useQuery<User>({\n    queryKey: ['users', userId],\n    url: `/users/${userId}`,\n    // Data is fresh for 5 minutes\n    staleTime: 5 * 60 * 1000,\n    // Keep in cache for 30 minutes\n    gcTime: 30 * 60 * 1000,\n  });\n\n  return (\n    <div>\n      {/* Show cached data immediately, refetch in background */}\n      {isFetching && !isLoading && <RefreshIndicator />}\n      {data && <UserCard user={data} />}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"cache-first",children:"Cache-First"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function CriticalData() {\n  const { data } = useQuery<Config>({\n    queryKey: ['config'],\n    url: '/config',\n    // Data never goes stale automatically\n    staleTime: Infinity,\n    // Manual refresh only\n    refetchOnMount: false,\n    refetchOnWindowFocus: false,\n    refetchOnReconnect: false,\n  });\n\n  return <ConfigDisplay config={data} />;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"network-first",children:"Network-First"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function RealTimeData() {\n  const { data } = useQuery<Stats>({\n    queryKey: ['stats'],\n    url: '/stats',\n    // Data is immediately stale\n    staleTime: 0,\n    // Always fetch fresh data\n    refetchOnMount: 'always',\n    refetchOnWindowFocus: 'always',\n  });\n\n  return <StatsDisplay stats={data} />;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"time-based-caching",children:"Time-Based Caching"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Short cache for frequently changing data\nconst { data: notifications } = useQuery({\n  queryKey: ['notifications'],\n  url: '/notifications',\n  staleTime: 30 * 1000, // 30 seconds\n  refetchInterval: 60 * 1000, // Refetch every minute\n});\n\n// Long cache for static data\nconst { data: countries } = useQuery({\n  queryKey: ['countries'],\n  url: '/countries',\n  staleTime: 24 * 60 * 60 * 1000, // 24 hours\n  gcTime: 7 * 24 * 60 * 60 * 1000, // 7 days\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cache-invalidation",children:"Cache Invalidation"}),"\n",(0,a.jsx)(n.h3,{id:"basic-invalidation",children:"Basic Invalidation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useQueryClient } from '@tanstack/react-query';\n\nfunction useInvalidateUsers() {\n  const queryClient = useQueryClient();\n\n  return {\n    // Invalidate all user queries\n    invalidateAll: () => {\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    },\n\n    // Invalidate specific user\n    invalidateUser: (userId: string) => {\n      queryClient.invalidateQueries({ queryKey: ['users', userId] });\n    },\n\n    // Invalidate with exact match\n    invalidateExact: (userId: string) => {\n      queryClient.invalidateQueries({\n        queryKey: ['users', userId],\n        exact: true,\n      });\n    },\n  };\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"invalidation-after-mutation",children:"Invalidation After Mutation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function useCreateUser() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    url: '/users',\n    method: 'POST',\n    onSuccess: () => {\n      // Invalidate users list to refetch\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    },\n  });\n}\n\nfunction useUpdateUser() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    url: (vars) => `/users/${vars.id}`,\n    method: 'PATCH',\n    onSuccess: (data, variables) => {\n      // Update cache directly\n      queryClient.setQueryData(['users', variables.id], data);\n      // Invalidate list\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    },\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"tag-based-invalidation",children:"Tag-Based Invalidation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { createQueryKeyStore } from '@54vie/api';\n\nconst queryKeys = createQueryKeyStore({\n  users: {\n    all: ['users'] as const,\n    list: (filters: UserFilters) => ['users', 'list', filters] as const,\n    detail: (id: string) => ['users', 'detail', id] as const,\n  },\n  posts: {\n    all: ['posts'] as const,\n    list: (filters: PostFilters) => ['posts', 'list', filters] as const,\n    detail: (id: string) => ['posts', 'detail', id] as const,\n    byUser: (userId: string) => ['posts', 'user', userId] as const,\n  },\n});\n\n// Usage\nfunction useInvalidatePosts() {\n  const queryClient = useQueryClient();\n\n  return {\n    invalidateAll: () => {\n      queryClient.invalidateQueries({ queryKey: queryKeys.posts.all });\n    },\n    invalidateUserPosts: (userId: string) => {\n      queryClient.invalidateQueries({\n        queryKey: queryKeys.posts.byUser(userId),\n      });\n    },\n  };\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"predicate-based-invalidation",children:"Predicate-Based Invalidation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const queryClient = useQueryClient();\n\n// Invalidate all queries matching a predicate\nqueryClient.invalidateQueries({\n  predicate: (query) => {\n    // Invalidate all user-related queries\n    return query.queryKey[0] === 'users';\n  },\n});\n\n// Invalidate stale queries only\nqueryClient.invalidateQueries({\n  predicate: (query) => {\n    return query.state.isStale;\n  },\n});\n\n// Invalidate queries with errors\nqueryClient.invalidateQueries({\n  predicate: (query) => {\n    return query.state.status === 'error';\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"manual-cache-updates",children:"Manual Cache Updates"}),"\n",(0,a.jsx)(n.h3,{id:"setting-cache-data",children:"Setting Cache Data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const queryClient = useQueryClient();\n\n// Set data for a specific query\nqueryClient.setQueryData(['users', userId], updatedUser);\n\n// Update with previous data\nqueryClient.setQueryData<User[]>(['users'], (oldData) => {\n  if (!oldData) return [newUser];\n  return [...oldData, newUser];\n});\n\n// Set data with options\nqueryClient.setQueryData(\n  ['users', userId],\n  updatedUser,\n  { updatedAt: Date.now() }\n);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function useUpdateTodo() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    url: (vars) => `/todos/${vars.id}`,\n    method: 'PATCH',\n    onMutate: async (newTodo) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['todos'] });\n\n      // Snapshot previous value\n      const previousTodos = queryClient.getQueryData<Todo[]>(['todos']);\n\n      // Optimistically update\n      queryClient.setQueryData<Todo[]>(['todos'], (old) =>\n        old?.map((todo) =>\n          todo.id === newTodo.id ? { ...todo, ...newTodo } : todo\n        )\n      );\n\n      return { previousTodos };\n    },\n    onError: (err, newTodo, context) => {\n      // Rollback on error\n      queryClient.setQueryData(['todos'], context?.previousTodos);\n    },\n    onSettled: () => {\n      // Refetch to ensure consistency\n      queryClient.invalidateQueries({ queryKey: ['todos'] });\n    },\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"prefetching",children:"Prefetching"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const queryClient = useQueryClient();\n\n// Prefetch on hover\nfunction UserLink({ userId }: { userId: string }) {\n  const prefetchUser = () => {\n    queryClient.prefetchQuery({\n      queryKey: ['users', userId],\n      queryFn: () => api.get(`/users/${userId}`),\n      staleTime: 5 * 60 * 1000,\n    });\n  };\n\n  return (\n    <Link\n      to={`/users/${userId}`}\n      onMouseEnter={prefetchUser}\n      onFocus={prefetchUser}\n    >\n      View User\n    </Link>\n  );\n}\n\n// Prefetch on route change\nasync function prefetchRouteData(route: string) {\n  if (route.startsWith('/users/')) {\n    const userId = route.split('/')[2];\n    await queryClient.prefetchQuery({\n      queryKey: ['users', userId],\n      queryFn: () => api.get(`/users/${userId}`),\n    });\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"offline-support",children:"Offline Support"}),"\n",(0,a.jsx)(n.h3,{id:"basic-offline-setup",children:"Basic Offline Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { onlineManager } from '@tanstack/react-query';\nimport { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n// Create persister for offline storage\nconst asyncStoragePersister = createAsyncStoragePersister({\n  storage: AsyncStorage,\n});\n\n// Configure online manager\nonlineManager.setEventListener((setOnline) => {\n  return window.addEventListener('online', () => setOnline(true));\n});\n\n// Persist query client\npersistQueryClient({\n  queryClient,\n  persister: asyncStoragePersister,\n  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"offline-mutation-queue",children:"Offline Mutation Queue"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useMutation, useQueryClient, onlineManager } from '@tanstack/react-query';\n\ninterface MutationQueue {\n  id: string;\n  mutationFn: () => Promise<unknown>;\n  timestamp: number;\n}\n\nconst mutationQueue: MutationQueue[] = [];\n\nfunction useOfflineMutation<TData, TVariables>({\n  mutationFn,\n  onSuccess,\n  onError,\n}: {\n  mutationFn: (variables: TVariables) => Promise<TData>;\n  onSuccess?: (data: TData) => void;\n  onError?: (error: Error) => void;\n}) {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (variables: TVariables) => {\n      if (!onlineManager.isOnline()) {\n        // Queue mutation for later\n        const mutation = {\n          id: crypto.randomUUID(),\n          mutationFn: () => mutationFn(variables),\n          timestamp: Date.now(),\n        };\n\n        mutationQueue.push(mutation);\n        await saveMutationQueue(mutationQueue);\n\n        throw new Error('Offline - mutation queued');\n      }\n\n      return mutationFn(variables);\n    },\n    onSuccess,\n    onError,\n  });\n}\n\n// Sync queued mutations when online\nwindow.addEventListener('online', async () => {\n  const queue = await loadMutationQueue();\n\n  for (const mutation of queue) {\n    try {\n      await mutation.mutationFn();\n      // Remove from queue on success\n      queue.splice(queue.indexOf(mutation), 1);\n    } catch (error) {\n      console.error('Failed to sync mutation:', error);\n    }\n  }\n\n  await saveMutationQueue(queue);\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"network-status-hook",children:"Network Status Hook"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useOnlineManager } from '@tanstack/react-query';\n\nfunction NetworkStatus() {\n  const isOnline = useOnlineManager().isOnline();\n\n  if (!isOnline) {\n    return (\n      <div className=\"offline-banner\">\n        You are offline. Changes will be synced when you reconnect.\n      </div>\n    );\n  }\n\n  return null;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optimistic-offline-updates",children:"Optimistic Offline Updates"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function useOfflineTodoToggle() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (todo: Todo) => {\n      // Store mutation for offline sync\n      await storePendingMutation('todo:toggle', todo);\n\n      // Make API call if online\n      if (navigator.onLine) {\n        return api.patch(`/todos/${todo.id}`, {\n          completed: !todo.completed,\n        });\n      }\n\n      // Return optimistic data\n      return { ...todo, completed: !todo.completed };\n    },\n    onMutate: async (todo) => {\n      await queryClient.cancelQueries({ queryKey: ['todos'] });\n\n      const previousTodos = queryClient.getQueryData<Todo[]>(['todos']);\n\n      queryClient.setQueryData<Todo[]>(['todos'], (old) =>\n        old?.map((t) =>\n          t.id === todo.id ? { ...t, completed: !t.completed } : t\n        )\n      );\n\n      return { previousTodos };\n    },\n    onError: (err, todo, context) => {\n      queryClient.setQueryData(['todos'], context?.previousTodos);\n    },\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cache-persistence",children:"Cache Persistence"}),"\n",(0,a.jsx)(n.h3,{id:"localstorage-persistence",children:"localStorage Persistence"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import {\n  persistQueryClient,\n  PersistQueryClientProvider,\n} from '@tanstack/react-query-persist-client';\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';\n\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n  key: 'REACT_QUERY_CACHE',\n  throttleTime: 1000,\n  serialize: (data) => JSON.stringify(data),\n  deserialize: (data) => JSON.parse(data),\n});\n\nfunction App() {\n  return (\n    <PersistQueryClientProvider\n      client={queryClient}\n      persistOptions={{\n        persister,\n        maxAge: 24 * 60 * 60 * 1000, // 24 hours\n        buster: 'v1', // Cache version, change to invalidate\n      }}\n    >\n      <YourApp />\n    </PersistQueryClientProvider>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"selective-persistence",children:"Selective Persistence"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const persister = createSyncStoragePersister({\n  storage: window.localStorage,\n});\n\npersistQueryClient({\n  queryClient,\n  persister,\n  dehydrateOptions: {\n    shouldDehydrateQuery: (query) => {\n      // Only persist successful queries\n      if (query.state.status !== 'success') return false;\n\n      // Only persist specific queries\n      const key = query.queryKey[0];\n      const persistableKeys = ['users', 'config', 'preferences'];\n\n      return persistableKeys.includes(key as string);\n    },\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"encrypted-persistence",children:"Encrypted Persistence"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"async function encryptData(data: string, key: CryptoKey): Promise<string> {\n  const iv = crypto.getRandomValues(new Uint8Array(12));\n  const encodedData = new TextEncoder().encode(data);\n\n  const encrypted = await crypto.subtle.encrypt(\n    { name: 'AES-GCM', iv },\n    key,\n    encodedData\n  );\n\n  const combined = new Uint8Array(iv.length + encrypted.byteLength);\n  combined.set(iv);\n  combined.set(new Uint8Array(encrypted), iv.length);\n\n  return btoa(String.fromCharCode(...combined));\n}\n\nasync function decryptData(data: string, key: CryptoKey): Promise<string> {\n  const combined = Uint8Array.from(atob(data), (c) => c.charCodeAt(0));\n  const iv = combined.slice(0, 12);\n  const encrypted = combined.slice(12);\n\n  const decrypted = await crypto.subtle.decrypt(\n    { name: 'AES-GCM', iv },\n    key,\n    encrypted\n  );\n\n  return new TextDecoder().decode(decrypted);\n}\n\nconst encryptedPersister = createSyncStoragePersister({\n  storage: window.localStorage,\n  serialize: async (data) => encryptData(JSON.stringify(data), encryptionKey),\n  deserialize: async (data) => JSON.parse(await decryptData(data, encryptionKey)),\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"cache-garbage-collection",children:"Cache Garbage Collection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // Garbage collect unused queries after 5 minutes\n      gcTime: 5 * 60 * 1000,\n    },\n  },\n});\n\n// Manual garbage collection\nqueryClient.getQueryCache().clear();\n\n// Remove specific queries\nqueryClient.removeQueries({ queryKey: ['users'] });\n\n// Remove inactive queries only\nqueryClient.removeQueries({\n  predicate: (query) => {\n    return query.getObserversCount() === 0;\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Set appropriate staleTime"})," - Balance between data freshness and network requests"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use gcTime wisely"})," - Keep data in memory for quick access, but not indefinitely"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement optimistic updates"})," - Provide instant feedback for mutations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Persist critical data"})," - Use localStorage/IndexedDB for offline support"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Invalidate strategically"})," - Avoid over-invalidation that causes unnecessary refetches"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use query key factories"})," - Maintain consistent and type-safe query keys"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/api/api-client/client",children:"ApiClient"})," - Core HTTP client"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/api/api-client/hooks",children:"React Hooks"})," - useQuery, useMutation hooks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/api/api-client/websocket",children:"WebSocket Client"})," - Real-time communication"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);