"use strict";(globalThis.webpackChunk_54vie_cookbooks=globalThis.webpackChunk_54vie_cookbooks||[]).push([[888],{1767(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"api/api-client/hooks","title":"React Hooks","description":"React Query hooks for data fetching and mutations","source":"@site/docs/api/api-client/hooks.md","sourceDirName":"api/api-client","slug":"/api/api-client/hooks","permalink":"/api/api-client/hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/54vie/super-app/tree/main/cookbooks/docs/api/api-client/hooks.md","tags":[],"version":"current","frontMatter":{"title":"React Hooks","description":"React Query hooks for data fetching and mutations","package":"@54vie/api","category":"API Client"},"sidebar":"apiSidebar","previous":{"title":"ApiClient","permalink":"/api/api-client/client"},"next":{"title":"WebSocket Client","permalink":"/api/api-client/websocket"}}');var a=r(5178),s=r(8145);const i={title:"React Hooks",description:"React Query hooks for data fetching and mutations",package:"@54vie/api",category:"API Client"},o="React Hooks",l={},u=[{value:"Installation",id:"installation",level:2},{value:"Setup",id:"setup",level:2},{value:"TypeScript Interfaces",id:"typescript-interfaces",level:2},{value:"useQuery Hook",id:"usequery-hook",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"With Query Parameters",id:"with-query-parameters",level:3},{value:"Conditional Fetching",id:"conditional-fetching",level:3},{value:"Dependent Queries",id:"dependent-queries",level:3},{value:"Data Transformation with Select",id:"data-transformation-with-select",level:3},{value:"Polling with refetchInterval",id:"polling-with-refetchinterval",level:3},{value:"Placeholder Data",id:"placeholder-data",level:3},{value:"useMutation Hook",id:"usemutation-hook",level:2},{value:"Basic Usage",id:"basic-usage-1",level:3},{value:"Update Mutation",id:"update-mutation",level:3},{value:"Delete Mutation",id:"delete-mutation",level:3},{value:"Optimistic Updates",id:"optimistic-updates",level:3},{value:"Async Mutation",id:"async-mutation",level:3},{value:"useInfiniteQuery Hook",id:"useinfinitequery-hook",level:2},{value:"Basic Usage",id:"basic-usage-2",level:3},{value:"Offset-Based Pagination",id:"offset-based-pagination",level:3},{value:"Infinite Scroll with Intersection Observer",id:"infinite-scroll-with-intersection-observer",level:3},{value:"Bidirectional Infinite Query",id:"bidirectional-infinite-query",level:3},{value:"Query Client Utilities",id:"query-client-utilities",level:2},{value:"Prefetching Data",id:"prefetching-data",level:3},{value:"Manual Cache Updates",id:"manual-cache-updates",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Related",id:"related",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"react-hooks",children:"React Hooks"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"@54vie/api"})," package provides React hooks built on top of TanStack Query (React Query) for seamless data fetching, caching, and state management."]}),"\n",(0,a.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"npm install @54vie/api @tanstack/react-query\n# or\nyarn add @54vie/api @tanstack/react-query\n# or\npnpm add @54vie/api @tanstack/react-query\n"})}),"\n",(0,a.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { ApiProvider } from '@54vie/api';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)\n      retry: 3,\n      refetchOnWindowFocus: false,\n    },\n  },\n});\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ApiProvider baseURL=\"https://api.54vie.com/v1\">\n        <YourApp />\n      </ApiProvider>\n    </QueryClientProvider>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"typescript-interfaces",children:"TypeScript Interfaces"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"// Query Options\ninterface UseQueryOptions<TData, TError = ApiError> {\n  queryKey: QueryKey;\n  enabled?: boolean;\n  staleTime?: number;\n  gcTime?: number;\n  refetchInterval?: number | false;\n  refetchOnMount?: boolean | 'always';\n  refetchOnWindowFocus?: boolean | 'always';\n  refetchOnReconnect?: boolean | 'always';\n  retry?: boolean | number | ((failureCount: number, error: TError) => boolean);\n  retryDelay?: number | ((attemptIndex: number) => number);\n  select?: (data: TData) => TData;\n  placeholderData?: TData | (() => TData);\n  initialData?: TData | (() => TData);\n  onSuccess?: (data: TData) => void;\n  onError?: (error: TError) => void;\n  onSettled?: (data: TData | undefined, error: TError | null) => void;\n}\n\n// Query Result\ninterface UseQueryResult<TData, TError = ApiError> {\n  data: TData | undefined;\n  error: TError | null;\n  isLoading: boolean;\n  isFetching: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  isPending: boolean;\n  isStale: boolean;\n  status: 'pending' | 'error' | 'success';\n  fetchStatus: 'fetching' | 'paused' | 'idle';\n  refetch: () => Promise<UseQueryResult<TData, TError>>;\n  dataUpdatedAt: number;\n  errorUpdatedAt: number;\n}\n\n// Mutation Options\ninterface UseMutationOptions<TData, TVariables, TError = ApiError> {\n  mutationKey?: MutationKey;\n  onMutate?: (variables: TVariables) => Promise<unknown> | unknown;\n  onSuccess?: (data: TData, variables: TVariables, context: unknown) => void;\n  onError?: (error: TError, variables: TVariables, context: unknown) => void;\n  onSettled?: (\n    data: TData | undefined,\n    error: TError | null,\n    variables: TVariables,\n    context: unknown\n  ) => void;\n  retry?: boolean | number;\n  retryDelay?: number;\n}\n\n// Mutation Result\ninterface UseMutationResult<TData, TVariables, TError = ApiError> {\n  data: TData | undefined;\n  error: TError | null;\n  isLoading: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  isIdle: boolean;\n  isPending: boolean;\n  status: 'idle' | 'pending' | 'error' | 'success';\n  mutate: (variables: TVariables) => void;\n  mutateAsync: (variables: TVariables) => Promise<TData>;\n  reset: () => void;\n  variables: TVariables | undefined;\n}\n\n// Infinite Query Options\ninterface UseInfiniteQueryOptions<TData, TError = ApiError> {\n  queryKey: QueryKey;\n  initialPageParam: unknown;\n  getNextPageParam: (lastPage: TData, allPages: TData[]) => unknown | undefined;\n  getPreviousPageParam?: (firstPage: TData, allPages: TData[]) => unknown | undefined;\n  maxPages?: number;\n  enabled?: boolean;\n  staleTime?: number;\n  gcTime?: number;\n  refetchInterval?: number | false;\n}\n\n// Infinite Query Result\ninterface UseInfiniteQueryResult<TData, TError = ApiError> {\n  data: InfiniteData<TData> | undefined;\n  error: TError | null;\n  isLoading: boolean;\n  isFetching: boolean;\n  isFetchingNextPage: boolean;\n  isFetchingPreviousPage: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n  fetchNextPage: () => Promise<UseInfiniteQueryResult<TData, TError>>;\n  fetchPreviousPage: () => Promise<UseInfiniteQueryResult<TData, TError>>;\n  refetch: () => Promise<UseInfiniteQueryResult<TData, TError>>;\n}\n\ninterface InfiniteData<TData> {\n  pages: TData[];\n  pageParams: unknown[];\n}\n\n// API Types\ninterface ApiError {\n  message: string;\n  status?: number;\n  code?: string;\n  data?: unknown;\n}\n\ntype QueryKey = readonly unknown[];\ntype MutationKey = readonly unknown[];\n"})}),"\n",(0,a.jsx)(n.h2,{id:"usequery-hook",children:"useQuery Hook"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"useQuery"})," hook is used for fetching and caching data."]}),"\n",(0,a.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useQuery } from '@54vie/api';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, isLoading, error } = useQuery<User>({\n    queryKey: ['users', userId],\n    url: `/users/${userId}`,\n  });\n\n  if (isLoading) return <Spinner />;\n  if (error) return <Error message={error.message} />;\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.email}</p>\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"with-query-parameters",children:"With Query Parameters"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface UsersResponse {\n  users: User[];\n  total: number;\n  page: number;\n}\n\nfunction UsersList({ page, status }: { page: number; status: string }) {\n  const { data, isLoading, isFetching } = useQuery<UsersResponse>({\n    queryKey: ['users', { page, status }],\n    url: '/users',\n    params: {\n      page,\n      limit: 10,\n      status,\n    },\n  });\n\n  return (\n    <div>\n      {isFetching && <LoadingOverlay />}\n      {data?.users.map((user) => (\n        <UserCard key={user.id} user={user} />\n      ))}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"conditional-fetching",children:"Conditional Fetching"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function UserDetails({ userId }: { userId: string | null }) {\n  const { data } = useQuery<User>({\n    queryKey: ['users', userId],\n    url: `/users/${userId}`,\n    // Only fetch when userId is available\n    enabled: !!userId,\n  });\n\n  return data ? <UserCard user={data} /> : null;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"dependent-queries",children:"Dependent Queries"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function UserPosts({ userId }: { userId: string }) {\n  // First query - get user\n  const userQuery = useQuery<User>({\n    queryKey: ['users', userId],\n    url: `/users/${userId}`,\n  });\n\n  // Second query - depends on first query\n  const postsQuery = useQuery<Post[]>({\n    queryKey: ['users', userId, 'posts'],\n    url: `/users/${userId}/posts`,\n    // Only fetch when user data is available\n    enabled: !!userQuery.data,\n  });\n\n  return (\n    <div>\n      <UserHeader user={userQuery.data} />\n      <PostsList posts={postsQuery.data} loading={postsQuery.isLoading} />\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"data-transformation-with-select",children:"Data Transformation with Select"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface ApiUser {\n  user_id: string;\n  full_name: string;\n  email_address: string;\n  created_at: string;\n}\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  createdAt: Date;\n}\n\nfunction useUser(userId: string) {\n  return useQuery<ApiUser, User>({\n    queryKey: ['users', userId],\n    url: `/users/${userId}`,\n    // Transform API response to app format\n    select: (data) => ({\n      id: data.user_id,\n      name: data.full_name,\n      email: data.email_address,\n      createdAt: new Date(data.created_at),\n    }),\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"polling-with-refetchinterval",children:"Polling with refetchInterval"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function LiveStats() {\n  const { data } = useQuery<Stats>({\n    queryKey: ['stats'],\n    url: '/stats',\n    // Refetch every 5 seconds\n    refetchInterval: 5000,\n    // Stop polling when tab is hidden\n    refetchIntervalInBackground: false,\n  });\n\n  return <StatsDisplay stats={data} />;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"placeholder-data",children:"Placeholder Data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function UserProfile({ userId }: { userId: string }) {\n  const { data } = useQuery<User>({\n    queryKey: ['users', userId],\n    url: `/users/${userId}`,\n    // Show placeholder while loading\n    placeholderData: {\n      id: userId,\n      name: 'Loading...',\n      email: '',\n    },\n  });\n\n  return <UserCard user={data} />;\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"usemutation-hook",children:"useMutation Hook"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"useMutation"})," hook is used for creating, updating, and deleting data."]}),"\n",(0,a.jsx)(n.h3,{id:"basic-usage-1",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useMutation, useQueryClient } from '@54vie/api';\n\ninterface CreateUserInput {\n  name: string;\n  email: string;\n}\n\nfunction CreateUserForm() {\n  const queryClient = useQueryClient();\n\n  const createUser = useMutation<User, CreateUserInput>({\n    url: '/users',\n    method: 'POST',\n    onSuccess: (newUser) => {\n      // Invalidate and refetch users list\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n      toast.success(`User ${newUser.name} created!`);\n    },\n    onError: (error) => {\n      toast.error(error.message);\n    },\n  });\n\n  const handleSubmit = (data: CreateUserInput) => {\n    createUser.mutate(data);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* form fields */}\n      <button type=\"submit\" disabled={createUser.isPending}>\n        {createUser.isPending ? 'Creating...' : 'Create User'}\n      </button>\n    </form>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"update-mutation",children:"Update Mutation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface UpdateUserInput {\n  id: string;\n  name?: string;\n  email?: string;\n}\n\nfunction useUpdateUser() {\n  const queryClient = useQueryClient();\n\n  return useMutation<User, UpdateUserInput>({\n    url: (variables) => `/users/${variables.id}`,\n    method: 'PATCH',\n    onSuccess: (updatedUser) => {\n      // Update the specific user in cache\n      queryClient.setQueryData(['users', updatedUser.id], updatedUser);\n      // Invalidate the users list\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    },\n  });\n}\n\nfunction EditUserForm({ user }: { user: User }) {\n  const updateUser = useUpdateUser();\n\n  const handleSave = (data: Partial<User>) => {\n    updateUser.mutate({ id: user.id, ...data });\n  };\n\n  return (\n    <form onSubmit={handleSave}>\n      {/* form fields */}\n      {updateUser.isError && <ErrorAlert error={updateUser.error} />}\n    </form>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"delete-mutation",children:"Delete Mutation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function useDeleteUser() {\n  const queryClient = useQueryClient();\n\n  return useMutation<void, { id: string }>({\n    url: (variables) => `/users/${variables.id}`,\n    method: 'DELETE',\n    onSuccess: (_, variables) => {\n      // Remove from cache\n      queryClient.removeQueries({ queryKey: ['users', variables.id] });\n      // Invalidate list\n      queryClient.invalidateQueries({ queryKey: ['users'] });\n    },\n  });\n}\n\nfunction DeleteUserButton({ userId }: { userId: string }) {\n  const deleteUser = useDeleteUser();\n\n  const handleDelete = () => {\n    if (confirm('Are you sure?')) {\n      deleteUser.mutate({ id: userId });\n    }\n  };\n\n  return (\n    <button onClick={handleDelete} disabled={deleteUser.isPending}>\n      {deleteUser.isPending ? 'Deleting...' : 'Delete'}\n    </button>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface Todo {\n  id: string;\n  title: string;\n  completed: boolean;\n}\n\nfunction useToggleTodo() {\n  const queryClient = useQueryClient();\n\n  return useMutation<Todo, { id: string; completed: boolean }>({\n    url: (variables) => `/todos/${variables.id}`,\n    method: 'PATCH',\n    // Optimistic update\n    onMutate: async (variables) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['todos'] });\n\n      // Snapshot previous value\n      const previousTodos = queryClient.getQueryData<Todo[]>(['todos']);\n\n      // Optimistically update\n      queryClient.setQueryData<Todo[]>(['todos'], (old) =>\n        old?.map((todo) =>\n          todo.id === variables.id\n            ? { ...todo, completed: variables.completed }\n            : todo\n        )\n      );\n\n      // Return context with snapshot\n      return { previousTodos };\n    },\n    // Rollback on error\n    onError: (error, variables, context) => {\n      if (context?.previousTodos) {\n        queryClient.setQueryData(['todos'], context.previousTodos);\n      }\n      toast.error('Failed to update todo');\n    },\n    // Refetch after success or error\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ['todos'] });\n    },\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"async-mutation",children:"Async Mutation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"async function handleSubmit() {\n  try {\n    const newUser = await createUser.mutateAsync({\n      name: 'John',\n      email: 'john@example.com',\n    });\n\n    // Navigate after successful creation\n    router.push(`/users/${newUser.id}`);\n  } catch (error) {\n    // Error is already handled by onError callback\n    console.error('Creation failed:', error);\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"useinfinitequery-hook",children:"useInfiniteQuery Hook"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"useInfiniteQuery"})," hook is used for paginated or infinite scroll data."]}),"\n",(0,a.jsx)(n.h3,{id:"basic-usage-2",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useInfiniteQuery } from '@54vie/api';\n\ninterface PostsResponse {\n  posts: Post[];\n  nextCursor: string | null;\n  hasMore: boolean;\n}\n\nfunction InfinitePostsList() {\n  const {\n    data,\n    isLoading,\n    isFetchingNextPage,\n    hasNextPage,\n    fetchNextPage,\n  } = useInfiniteQuery<PostsResponse>({\n    queryKey: ['posts'],\n    url: '/posts',\n    initialPageParam: null,\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n  });\n\n  if (isLoading) return <Spinner />;\n\n  return (\n    <div>\n      {data?.pages.map((page, i) => (\n        <Fragment key={i}>\n          {page.posts.map((post) => (\n            <PostCard key={post.id} post={post} />\n          ))}\n        </Fragment>\n      ))}\n\n      <button\n        onClick={() => fetchNextPage()}\n        disabled={!hasNextPage || isFetchingNextPage}\n      >\n        {isFetchingNextPage\n          ? 'Loading more...'\n          : hasNextPage\n          ? 'Load More'\n          : 'No more posts'}\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"offset-based-pagination",children:"Offset-Based Pagination"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  pageSize: number;\n}\n\nfunction useInfiniteUsers() {\n  return useInfiniteQuery<PaginatedResponse<User>>({\n    queryKey: ['users', 'infinite'],\n    url: '/users',\n    initialPageParam: 1,\n    getNextPageParam: (lastPage) => {\n      const totalPages = Math.ceil(lastPage.total / lastPage.pageSize);\n      return lastPage.page < totalPages ? lastPage.page + 1 : undefined;\n    },\n    getPreviousPageParam: (firstPage) => {\n      return firstPage.page > 1 ? firstPage.page - 1 : undefined;\n    },\n  });\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"infinite-scroll-with-intersection-observer",children:"Infinite Scroll with Intersection Observer"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useRef, useEffect } from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nfunction InfiniteScrollList() {\n  const { ref, inView } = useInView();\n\n  const {\n    data,\n    fetchNextPage,\n    hasNextPage,\n    isFetchingNextPage,\n  } = useInfiniteQuery<PostsResponse>({\n    queryKey: ['posts'],\n    url: '/posts',\n    initialPageParam: null,\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n  });\n\n  // Fetch next page when sentinel comes into view\n  useEffect(() => {\n    if (inView && hasNextPage && !isFetchingNextPage) {\n      fetchNextPage();\n    }\n  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);\n\n  return (\n    <div>\n      {data?.pages.map((page, i) => (\n        <Fragment key={i}>\n          {page.posts.map((post) => (\n            <PostCard key={post.id} post={post} />\n          ))}\n        </Fragment>\n      ))}\n\n      {/* Sentinel element */}\n      <div ref={ref}>\n        {isFetchingNextPage && <Spinner />}\n      </div>\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"bidirectional-infinite-query",children:"Bidirectional Infinite Query"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function ChatMessages({ channelId }: { channelId: string }) {\n  const {\n    data,\n    fetchNextPage,\n    fetchPreviousPage,\n    hasNextPage,\n    hasPreviousPage,\n    isFetchingNextPage,\n    isFetchingPreviousPage,\n  } = useInfiniteQuery<MessagesResponse>({\n    queryKey: ['channels', channelId, 'messages'],\n    url: `/channels/${channelId}/messages`,\n    initialPageParam: { cursor: null, direction: 'forward' },\n    getNextPageParam: (lastPage) =>\n      lastPage.hasMore ? { cursor: lastPage.nextCursor, direction: 'forward' } : undefined,\n    getPreviousPageParam: (firstPage) =>\n      firstPage.hasPrevious ? { cursor: firstPage.prevCursor, direction: 'backward' } : undefined,\n    maxPages: 10, // Keep only 10 pages in memory\n  });\n\n  return (\n    <div>\n      {hasPreviousPage && (\n        <button onClick={() => fetchPreviousPage()}>\n          {isFetchingPreviousPage ? 'Loading...' : 'Load Previous'}\n        </button>\n      )}\n\n      {data?.pages.map((page) =>\n        page.messages.map((message) => (\n          <Message key={message.id} message={message} />\n        ))\n      )}\n\n      {hasNextPage && (\n        <button onClick={() => fetchNextPage()}>\n          {isFetchingNextPage ? 'Loading...' : 'Load More'}\n        </button>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"query-client-utilities",children:"Query Client Utilities"}),"\n",(0,a.jsx)(n.h3,{id:"prefetching-data",children:"Prefetching Data"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { useQueryClient } from '@54vie/api';\n\nfunction UsersList({ users }: { users: User[] }) {\n  const queryClient = useQueryClient();\n\n  const handleMouseEnter = (userId: string) => {\n    // Prefetch user details on hover\n    queryClient.prefetchQuery({\n      queryKey: ['users', userId],\n      queryFn: () => client.get(`/users/${userId}`),\n    });\n  };\n\n  return (\n    <ul>\n      {users.map((user) => (\n        <li\n          key={user.id}\n          onMouseEnter={() => handleMouseEnter(user.id)}\n        >\n          <Link to={`/users/${user.id}`}>{user.name}</Link>\n        </li>\n      ))}\n    </ul>\n  );\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"manual-cache-updates",children:"Manual Cache Updates"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const queryClient = useQueryClient();\n\n// Set data directly\nqueryClient.setQueryData(['users', userId], updatedUser);\n\n// Update with callback\nqueryClient.setQueryData<User[]>(['users'], (old) =>\n  old?.map((user) => (user.id === userId ? updatedUser : user))\n);\n\n// Invalidate queries\nqueryClient.invalidateQueries({ queryKey: ['users'] });\n\n// Remove queries\nqueryClient.removeQueries({ queryKey: ['users', userId] });\n\n// Reset queries\nqueryClient.resetQueries({ queryKey: ['users'] });\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Use meaningful query keys"})," - Include all variables that affect the query"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Configure stale time"})," - Set appropriate ",(0,a.jsx)(n.code,{children:"staleTime"})," based on data freshness needs"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Implement optimistic updates"})," - Provide instant feedback for mutations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle loading and error states"})," - Always show appropriate UI feedback"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.strong,{children:["Use ",(0,a.jsx)(n.code,{children:"select"})]})," - Transform data at the hook level instead of in components"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Prefetch data"})," - Improve perceived performance with prefetching"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related",children:"Related"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/api/api-client/client",children:"ApiClient"})," - Core HTTP client"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/api/api-client/websocket",children:"WebSocket Client"})," - Real-time communication"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/api/api-client/cache",children:"Caching"})," - Response caching and offline support"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8145(e,n,r){r.d(n,{R:()=>i,x:()=>o});var t=r(5410);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);